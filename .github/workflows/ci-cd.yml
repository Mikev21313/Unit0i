// WebHelp Content Server for Google Drive
// Configure these variables with your specific values
const DRIVE_FOLDER_ID = 'YOUR_FOLDER_ID_HERE'; // Replace with your Google Drive folder ID
const DEFAULT_FILE = 'index.html';
const CACHE_DURATION = 300; // Cache duration in seconds (5 minutes)

/**
 * Main entry point - handles all HTTP GET requests
 */
function doGet(e) {
  try {
    // Extract requested path from parameters
    const requestedPath = e.parameter.path || DEFAULT_FILE;
    
    // Security: Prevent directory traversal attacks
    if (requestedPath.includes('..') || requestedPath.includes('//')) {
      return createErrorResponse('Invalid path requested', 400);
    }
    
    // Log request for debugging (remove in production for performance)
    console.log('Requested path:', requestedPath);
    
    // Fetch and serve the requested file
    return serveFile(requestedPath);
    
  } catch (error) {
    console.error('Error in doGet:', error);
    return createErrorResponse('Internal server error: ' + error.message, 500);
  }
}

/**
 * Serves a file from Google Drive with appropriate headers
 */
function serveFile(filePath) {
  try {
    // Get the file from Drive
    const file = findFileInFolder(filePath, DRIVE_FOLDER_ID);
    
    if (!file) {
      // Try common fallbacks
      if (filePath.endsWith('/')) {
        return serveFile(filePath + 'index.html');
      }
      return createErrorResponse('File not found: ' + filePath, 404);
    }
    
    // Get file content
    const blob = file.getBlob();
    const content = blob.getBytes();
    
    // Determine MIME type
    const mimeType = getMimeType(filePath, blob.getContentType());
    
    // Create response with appropriate headers
    const response = Utilities.newBlob(content).setContentType(mimeType);
    
    // Build HTML output with proper headers for iframe compatibility
    const output = HtmlService.createOutput(response.getDataAsString())
      .setTitle('WebHelp Documentation')
      .setSandboxMode(HtmlService.SandboxMode.IFRAME)
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
    
    // Add cache control for performance
    return output.addMetaTag('Cache-Control', 'public, max-age=' + CACHE_DURATION);
    
  } catch (error) {
    console.error('Error serving file:', error);
    return createErrorResponse('Error loading file: ' + error.message, 500);
  }
}

/**
 * Finds a file in the specified Drive folder (including subfolders)
 */
function findFileInFolder(filePath, folderId) {
  try {
    // Split path into components
    const pathParts = filePath.split('/').filter(part => part);
    
    // Start from root folder
    let currentFolder = DriveApp.getFolderById(folderId);
    
    // Navigate through subdirectories
    for (let i = 0; i < pathParts.length - 1; i++) {
      const folderName = pathParts[i];
      const subfolders = currentFolder.getFoldersByName(folderName);
      
      if (!subfolders.hasNext()) {
        console.log('Folder not found:', folderName);
        return null;
      }
      
      currentFolder = subfolders.next();
    }
    
    // Get the actual file
    const fileName = pathParts[pathParts.length - 1];
    const files = currentFolder.getFilesByName(fileName);
    
    if (!files.hasNext()) {
      console.log('File not found:', fileName);
      return null;
    }
    
    return files.next();
    
  } catch (error) {
    console.error('Error finding file:', error);
    return null;
  }
}

/**
 * Determines appropriate MIME type for response
 */
function getMimeType(filePath, defaultType) {
  const extension = filePath.split('.').pop().toLowerCase();
  
  const mimeTypes = {
    'html': 'text/html',
    'htm': 'text/html',
    'css': 'text/css',
    'js': 'application/javascript',
    'json': 'application/json',
    'xml': 'application/xml',
    'png': 'image/png',
    'jpg': 'image/jpeg',
    'jpeg': 'image/jpeg',
    'gif': 'image/gif',
    'svg': 'image/svg+xml',
    'ico': 'image/x-icon',
    'woff': 'font/woff',
    'woff2': 'font/woff2',
    'ttf': 'font/ttf',
    'eot': 'application/vnd.ms-fontobject',
    'pdf': 'application/pdf',
    'zip': 'application/zip'
  };
  
  return mimeTypes[extension] || defaultType || 'application/octet-stream';
}

/**
 * Creates an error response with proper HTML formatting
 */
function createErrorResponse(message, code) {
  const html = `
    <!DOCTYPE html>
    <html>
      <head>
        <title>Error ${code}</title>
        <style>
          body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f5f5f5;
          }
          .error-container {
            text-align: center;
            padding: 2rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
          }
          h1 { color: #d32f2f; }
          p { color: #666; }
        </style>
      </head>
      <body>
        <div class="error-container">
          <h1>Error ${code}</h1>
          <p>${message}</p>
        </div>
      </body>
    </html>
  `;
  
  return HtmlService.createHtmlOutput(html)
    .setSandboxMode(HtmlService.SandboxMode.IFRAME)
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

/**
 * Configuration function - Run this once to set up permissions
 */
function setupPermissions() {
  // This function forces authorization prompt when run
  DriveApp.getFolderById(DRIVE_FOLDER_ID);
  console.log('Permissions configured successfully');
}

/**
 * Test function - Verifies folder access
 */
function testFolderAccess() {
  try {
    const folder = DriveApp.getFolderById(DRIVE_FOLDER_ID);
    console.log('Folder name:', folder.getName());
    
    // List first 10 files
    const files = folder.getFiles();
    let count = 0;
    while (files.hasNext() && count < 10) {
      const file = files.next();
      console.log('File:', file.getName(), 'Type:', file.getMimeType());
      count++;
    }
    
    return 'Folder access successful';
  } catch (error) {
    return 'Error accessing folder: ' + error.message;
  }
}